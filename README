This is a very early stage of what could become a riot-sys and surrounding
crates. The ideas is to write applications in Rust (eg. using embedded-hal),
and execute them on RIOT. A riot-embedded-hal could export RIOT's established
peripherals to Rust's embedded-hal API, building on a manual or bindgen-managed
riot-sys crate(s?).

On using bindgen
----------------

Some parts of the RUST API depend on board specifics; that can be the presence
of fields in structs (eg. gnrc_netif_t) or even complete types (i2c_t); the
bindgen run thus necessarily needs to know which setup the crate was built for.

The information about the setup is most easily transported in the expanded
headers; for that, add the following lines at the end of your RIOT project's
Makefile:

~~~~

for-cargo: ${BINDIR}/riot-expanded-headers.h

${BINDIR}/riot-expanded-headers.h: ../../riot-sys/riot-all.h
	$(Q)$(CC) $(CFLAGS_WITH_MACROS) $(INCLUDES) $< -fdirectives-only -E -o $@
	@echo "You may now run cargo with RIOT_EXPANDED_HEADER=$@ RIOT_CFLAGS=\"${RIOT_CFLAGS}\""

.PHONY: for-cargo
~~~~

Then, run `make for-cargo` (possibly with your `BOARD=` parameter), and prefix
the resulting environment variable to your cargo invocations.
